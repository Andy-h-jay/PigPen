<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>pigpen.fold documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Pigpen</span> <span class="project-version">0.3.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pigpen</span></div></div></li><li class="depth-2 branch"><a href="pigpen.avro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>avro</span></div></a></li><li class="depth-2 branch"><a href="pigpen.cascading.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cascading</span></div></a></li><li class="depth-2"><a href="pigpen.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="pigpen.core.fn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fn</span></div></a></li><li class="depth-3"><a href="pigpen.core.op.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>op</span></div></a></li><li class="depth-2 branch current"><a href="pigpen.fold.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>fold</span></div></a></li><li class="depth-2 branch"><a href="pigpen.parquet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parquet</span></div></a></li><li class="depth-2 branch"><a href="pigpen.pig.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pig</span></div></a></li><li class="depth-2 branch"><a href="pigpen.rx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rx</span></div></a></li><li class="depth-2"><a href="pigpen.viz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>viz</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="pigpen.fold.html#var-avg"><div class="inner"><span>avg</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-count"><div class="inner"><span>count</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-distinct"><div class="inner"><span>distinct</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-first"><div class="inner"><span>first</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-fold-fn"><div class="inner"><span>fold-fn</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-juxt"><div class="inner"><span>juxt</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-keep"><div class="inner"><span>keep</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-last"><div class="inner"><span>last</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-mapcat"><div class="inner"><span>mapcat</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-max"><div class="inner"><span>max</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-max-key"><div class="inner"><span>max-key</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-min"><div class="inner"><span>min</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-min-key"><div class="inner"><span>min-key</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-preprocess"><div class="inner"><span>preprocess</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-remove"><div class="inner"><span>remove</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-sort"><div class="inner"><span>sort</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-sort-by"><div class="inner"><span>sort-by</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-sum"><div class="inner"><span>sum</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-take"><div class="inner"><span>take</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-top"><div class="inner"><span>top</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-top-by"><div class="inner"><span>top-by</span></div></a></li><li class="depth-1"><a href="pigpen.fold.html#var-vec"><div class="inner"><span>vec</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">pigpen.fold</h1><div class="doc"><pre class="plaintext">Fold operations for use with pig/fold, pig/group-by, and pig/cogroup.

See <a href="https://github.com/Netflix/PigPen/wiki/Folding-Data">https://github.com/Netflix/PigPen/wiki/Folding-Data</a></pre></div><div class="public anchor" id="var-avg"><h3>avg</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(avg)</code><code>(avg fold)</code></div><div class="doc"><pre class="plaintext">Average the values. All values must be numeric. Optionally takes another
fold operation to compose.

  Example:
    (fold/avg)

    (-&gt;&gt; (fold/map :foo) (fold/avg)) ; average the foo's
    (-&gt;&gt; (fold/keep identity) (fold/avg)) ; avg non-nils
    (-&gt;&gt; (fold/filter #(&lt; 0 %)) (fold/avg)) ; avg positive numbers

    (-&gt;&gt;
      (fold/map :foo)
      (fold/keep identity)
      (fold/avg))

  See also: pigpen.fold/count, pigpen.fold/sum</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L345">view source</a></div></div><div class="public anchor" id="var-count"><h3>count</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(count)</code><code>(count fold)</code></div><div class="doc"><pre class="plaintext">Counts the values, including nils. Optionally takes another fold operation
to compose.

  Example:
    (fold/count)

    (-&gt;&gt; (fold/keep identity) (fold/count)) ; count non-nils
    (-&gt;&gt; (fold/filter #(&lt; 0 %)) (fold/count)) ; count positive numbers

    (-&gt;&gt;
      (fold/map :foo)
      (fold/keep identity)
      (fold/count))

  See also: pigpen.fold/sum, pigpen.fold/avg</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L298">view source</a></div></div><div class="public anchor" id="var-distinct"><h3>distinct</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(distinct)</code><code>(distinct fold)</code></div><div class="doc"><pre class="plaintext">Returns the distinct set of values.

Example:
  (fold/distinct)

  (-&gt;&gt; (fold/map :foo)
       (fold/keep identity)
       (fold/distinct))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L139">view source</a></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(filter f)</code><code>(filter f fold)</code></div><div class="doc"><pre class="plaintext">Pre-processes data for a fold operation. Same as clojure.core/filter.
</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L135">view source</a></div></div><div class="public anchor" id="var-first"><h3>first</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(first)</code><code>(first fold)</code></div><div class="doc"><pre class="plaintext">Returns the first output value. This is a post-reduce operation, meaning that
it can only be applied after a fold operation that produces a sequence.

  Example:
    (fold/first)

    (-&gt;&gt; (fold/map :foo)
         (fold/sort)
         (fold/first))

  See also: pigpen.fold/last, pigpen.fold/min, pigpen.fold/max</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L171">view source</a></div></div><div class="public anchor" id="var-fold-fn"><h3>fold-fn</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(fold-fn reducef)</code><code>(fold-fn combinef reducef)</code><code>(fold-fn combinef reducef post)</code><code>(fold-fn pre combinef reducef post)</code></div><div class="doc"><pre class="plaintext">Creates a pre-defined fold operation. Can be used with cogroup and group-by
to aggregate large groupings in parallel. See pigpen.core/fold for usage of
reducef and combinef.

  Example:

    (def count
      (pig/fold-fn + (fn [acc _] (inc acc))))

    (def sum
      (pig/fold-fn +))

    (defn sum-by [f]
      (pig/fold-fn + (fn [acc value] (+ acc (f value)))))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L29">view source</a></div></div><div class="public anchor" id="var-juxt"><h3>juxt</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(juxt &amp; folds)</code></div><div class="doc"><pre class="plaintext">Applies multiple fold fns to the same data. Produces a vector of results.

Example:
  (fold/juxt (fold/count) (fold/sum) (fold/avg))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L262">view source</a></div></div><div class="public anchor" id="var-keep"><h3>keep</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(keep f)</code><code>(keep f fold)</code></div><div class="doc"><pre class="plaintext">Pre-processes data for a fold operation. Same as clojure.core/keep.
</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L137">view source</a></div></div><div class="public anchor" id="var-last"><h3>last</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(last)</code><code>(last fold)</code></div><div class="doc"><pre class="plaintext">Returns the last output value. This is a post-reduce operation, meaning that
it can only be applied after a fold operation that produces a sequence.

  Example:
    (fold/last)

    (-&gt;&gt; (fold/map :foo)
         (fold/sort)
         (fold/last))

  See also: pigpen.fold/first, pigpen.fold/min, pigpen.fold/max</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L191">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(map f)</code><code>(map f fold)</code></div><div class="doc"><pre class="plaintext">Pre-processes data for a fold operation. Same as clojure.core/map.
</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L133">view source</a></div></div><div class="public anchor" id="var-mapcat"><h3>mapcat</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(mapcat f)</code><code>(mapcat f fold)</code></div><div class="doc"><pre class="plaintext">Pre-processes data for a fold operation. Same as clojure.core/mapcat.
</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L134">view source</a></div></div><div class="public anchor" id="var-max"><h3>max</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(max)</code><code>(max fold)</code><code>(max comp)</code><code>(max comp fold)</code></div><div class="doc"><pre class="plaintext">Return the maximum (last) value of the collection. If a comparator is not
specified, clojure.core/compare is used. Optionally takes another fold
operation to compose.

  Example:
    (fold/max)
    (fold/max &gt;)

    (-&gt;&gt;
      (fold/map :foo)
      (fold/max &gt;))

  See also: pigpen.fold/max-key, pigpen.fold/min, pigpen.fold/top</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L473">view source</a></div></div><div class="public anchor" id="var-max-key"><h3>max-key</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(max-key keyfn)</code><code>(max-key keyfn fold)</code><code>(max-key keyfn comp)</code><code>(max-key keyfn comp fold)</code></div><div class="doc"><pre class="plaintext">Return the maximum (last) value of the collection based on (keyfn value).
If a comparator is not specified, clojure.core/compare is used. Optionally takes
another fold operation to compose.

  Example:
    (fold/max-key :foo)
    (fold/max-key :foo &gt;)

  See also: pigpen.fold/max, pigpen.fold/min-key, pigpen.fold/top-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L497">view source</a></div></div><div class="public anchor" id="var-min"><h3>min</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(min)</code><code>(min fold)</code><code>(min comp)</code><code>(min comp fold)</code></div><div class="doc"><pre class="plaintext">Return the minimum (first) value of the collection. If a comparator is not
specified, clojure.core/compare is used. Optionally takes another fold
operation to compose.

  Example:
    (fold/min)
    (fold/min &gt;)

    (-&gt;&gt;
      (fold/map :foo)
      (fold/min &gt;))

  See also: pigpen.fold/min-key, pigpen.fold/max, pigpen.fold/top</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L429">view source</a></div></div><div class="public anchor" id="var-min-key"><h3>min-key</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(min-key keyfn)</code><code>(min-key keyfn fold)</code><code>(min-key keyfn comp)</code><code>(min-key keyfn comp fold)</code></div><div class="doc"><pre class="plaintext">Return the minimum (first) value of the collection based on (keyfn value).
If a comparator is not specified, clojure.core/compare is used. Optionally takes
another fold operation to compose.

  Example:
    (fold/min-key :foo)
    (fold/min-key :foo &gt;)

  See also: pigpen.fold/min, pigpen.fold/max-key, pigpen.fold/top-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L453">view source</a></div></div><div class="public anchor" id="var-preprocess"><h3>preprocess</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(preprocess f')</code></div><div class="doc"><pre class="plaintext">Takes a a clojure seq function, like map or filter, and returns a fold
preprocess function. The function must take two params: a function and a seq.

  Example:

    (def map (preprocess clojure.core/map))

    (pig/fold (map :foo))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L107">view source</a></div></div><div class="public anchor" id="var-remove"><h3>remove</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(remove f)</code><code>(remove f fold)</code></div><div class="doc"><pre class="plaintext">Pre-processes data for a fold operation. Same as clojure.core/remove.
</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L136">view source</a></div></div><div class="public anchor" id="var-sort"><h3>sort</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(sort)</code><code>(sort fold)</code><code>(sort c fold)</code></div><div class="doc"><pre class="plaintext">Sorts the data. This sorts the data after every element, so it's best to use
with take, which also limits the data after every value. If a comparator is not
specified, clojure.core/compare is used.

  Example:

    (fold/sort)

    (-&gt;&gt;
      (fold/sort)
      (fold/take 40))

    (-&gt;&gt;
      (fold/sort &gt;)
      (fold/take 40))

  See also: pigpen.fold/sort-by, pigpen.fold/top</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L212">view source</a></div></div><div class="public anchor" id="var-sort-by"><h3>sort-by</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(sort-by keyfn)</code><code>(sort-by keyfn fold)</code><code>(sort-by keyfn c fold)</code></div><div class="doc"><pre class="plaintext">Sorts the data by (keyfn value). This sorts the data after every element, so
it's best to use with take, which also limits the data after every value. If a
comparator is not specified, clojure.core/compare is used.

  Example:

    (fold/sort-by :foo)

    (-&gt;&gt; (vec)
      (fold/sort-by :foo)
      (fold/take 40))

    (-&gt;&gt; (vec)
      (fold/sort-by :foo &gt;)
      (fold/take 40))

  See also: pigpen.fold/sort, pigpen.fold/top-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L237">view source</a></div></div><div class="public anchor" id="var-sum"><h3>sum</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(sum)</code><code>(sum fold)</code></div><div class="doc"><pre class="plaintext">Sums the values. All values must be numeric. Optionally takes another
fold operation to compose.

  Example:
    (fold/sum)

    (-&gt;&gt; (fold/map :foo) (fold/sum)) ; sum the foo's
    (-&gt;&gt; (fold/keep identity) (fold/sum)) ; sum non-nils
    (-&gt;&gt; (fold/filter #(&lt; 0 %)) (fold/sum)) ; sum positive numbers

    (-&gt;&gt;
      (fold/map :foo)
      (fold/keep identity)
      (fold/sum))

  See also: pigpen.fold/count, pigpen.fold/avg</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L321">view source</a></div></div><div class="public anchor" id="var-take"><h3>take</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(take n)</code><code>(take n fold)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of the first n items in coll. This is a post-reduce
operation, meaning that it can only be applied after a fold operation that
produces a sequence.

  Example:

    (-&gt;&gt;
      (fold/sort)
      (fold/take 40))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L155">view source</a></div></div><div class="public anchor" id="var-top"><h3>top</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(top n)</code><code>(top comp n)</code></div><div class="doc"><pre class="plaintext">Returns the top n items in the collection. If a comparator is not specified,
clojure.core/compare is used.

  Example:
    (fold/top 40)
    (fold/top &gt; 40)

  See also: pigpen.fold/top-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L377">view source</a></div></div><div class="public anchor" id="var-top-by"><h3>top-by</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(top-by keyfn n)</code><code>(top-by keyfn comp n)</code></div><div class="doc"><pre class="plaintext">Returns the top n items in the collection based on (keyfn value). If a
comparator is not specified, clojure.core/compare is used.

  Example:
    (fold/top-by :foo 40)
    (fold/top-by :foo &gt; 40)

  See also: pigpen.fold/top</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L394">view source</a></div></div><div class="public anchor" id="var-vec"><h3>vec</h3><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(vec)</code></div><div class="doc"><pre class="plaintext">Returns all values as a vector. This is the default fold operation if none
other is specified.

  Example:
    (fold/vec)

    (-&gt;&gt; (fold/vec)
      (fold/take 5))</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/fold.clj#L90">view source</a></div></div></div></body></html>