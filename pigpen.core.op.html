<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>pigpen.core.op documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pigpen 0.3.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="pigpen.core.html"><span>pigpen.core</span></a></li><li><a href="pigpen.core.fn.html"><span>pigpen.core.fn</span></a></li><li class="current"><a href="pigpen.core.op.html"><span>pigpen.core.op</span></a></li><li><a href="pigpen.fold.html"><span>pigpen.fold</span></a></li><li><a href="pigpen.rx.html"><span>pigpen.rx</span></a></li><li><a href="pigpen.pig.html"><span>pigpen.pig</span></a></li><li><a href="pigpen.cascading.html"><span>pigpen.cascading</span></a></li><li><a href="pigpen.parquet.html"><span>pigpen.parquet</span></a></li><li><a href="pigpen.avro.html"><span>pigpen.avro</span></a></li><li><a href="pigpen.viz.html"><span>pigpen.viz</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="pigpen.core.op.html#var-bind%24"><span>bind$</span></a></li><li><a href="pigpen.core.op.html#var-code%24"><span>code$</span></a></li><li><a href="pigpen.core.op.html#var-concat%24"><span>concat$</span></a></li><li><a href="pigpen.core.op.html#var-distinct%24"><span>distinct$</span></a></li><li><a href="pigpen.core.op.html#var-filter-%3Ebind"><span>filter-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-group%24"><span>group$</span></a></li><li><a href="pigpen.core.op.html#var-indexed-field-selector-%3Ebind"><span>indexed-field-selector-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-join%24"><span>join$</span></a></li><li><a href="pigpen.core.op.html#var-key-selector-%3Ebind"><span>key-selector-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-keyword-field-selector-%3Ebind"><span>keyword-field-selector-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-load%24"><span>load$</span></a></li><li><a href="pigpen.core.op.html#var-map-%3Ebind"><span>map-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-mapcat-%3Ebind"><span>mapcat-&gt;bind</span></a></li><li><a href="pigpen.core.op.html#var-noop%24"><span>noop$</span></a></li><li><a href="pigpen.core.op.html#var-project%24"><span>project$</span></a></li><li><a href="pigpen.core.op.html#var-projection-field%24"><span>projection-field$</span></a></li><li><a href="pigpen.core.op.html#var-projection-func%24"><span>projection-func$</span></a></li><li><a href="pigpen.core.op.html#var-rank%24"><span>rank$</span></a></li><li><a href="pigpen.core.op.html#var-reduce%24"><span>reduce$</span></a></li><li><a href="pigpen.core.op.html#var-return%24"><span>return$</span></a></li><li><a href="pigpen.core.op.html#var-sample%24"><span>sample$</span></a></li><li><a href="pigpen.core.op.html#var-sort%24"><span>sort$</span></a></li><li><a href="pigpen.core.op.html#var-store%24"><span>store$</span></a></li><li><a href="pigpen.core.op.html#var-store-many%24"><span>store-many$</span></a></li><li><a href="pigpen.core.op.html#var-take%24"><span>take$</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>pigpen.core.op documentation</h2><pre class="doc">*** ALPHA - Subject to change ***

  The raw pigpen operators. These are the basic building blocks that platforms
implement. All higher level operators are defined in terms of these operators.
These should be used to build custom PigPen operators. In these examples, fields
refers to the fields that the underlying platform is aware of. Usually this is a
single user field that represents arbitrary Clojure data.

  Note: You most likely don't want this namespace. Unless you are doing advanced
things, stick to pigpen.core</pre><div class="public" id="var-bind%24"><h3>bind$</h3><div class="usage"><code>(bind$ func opts relation)</code><code>(bind$ requires func opts relation)</code></div><pre class="doc">Inputs: ([func opts relation] [requires func opts relation])
  Returns: m/Bind$

  The way to apply user code to a relation. `func` should be a function that
takes a collection of arguments, and returns a collection of result tuples.
Optionally takes a collection of namespaces to require before executing user
code.

  Example:

    (bind$
      (fn [args]
        ;; do stuff to args, return a value like this:
        [[foo-value bar-value]   ;; result 1
         [foo-value bar-value]   ;; result 2
         ...
         [foo-value bar-value]]) ;; result N
      {:args  '[x y]
       :alias '[foo bar]}
      relation)

  In this example, our function takes `args` which is a tuple of argument values
from the previous relation. Here, this selects the fields x and y. The function
then returns 0-to-many result tuples. Each of those tuples maps to the fields
specified by the alias option. If not specified, args defaults to the fields of
the input relation and alias defaults to a single field `value`. All field names
should be symbols.

  There are many provided bind helper functions, such as map-&gt;bind, that take a
normal map function of one arg to one result, and convert it to a bind function.

    (bind$
      (map-&gt;bind (fn [x] (* x x)))
      {}
      data)

  See also: pigpen.core.fn/map-&gt;bind, pigpen.core.fn/mapcat-&gt;bind,
            pigpen.core.fn/filter-&gt;bind, pigpen.core.fn/process-&gt;bind,
            pigpen.core.fn/key-selector-&gt;bind,
            pigpen.core.fn/keyword-field-selector-&gt;bind,
            pigpen.core.fn/indexed-field-selector-&gt;bind</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L277">Source</a></div></div><div class="public" id="var-code%24"><h3>code$</h3><div class="usage"><code>(code$ udf init func args)</code></div><pre class="doc">Inputs: [udf init func args]
  Returns: m/CodeExpr

  Encapsulation for user code. Used with projection-func$ and project$. You
probably want bind$ instead of this.

The parameter `udf` should be one of:

  :seq    - returns zero or more values
  :fold   - apply a fold aggregation

The parameter `init` is code to be executed once before the user code, `func` is
the user code to execute, and `args` specifies which fields should be passed to
`func`. `args` can also contain strings, which are passed through as constants
to the user code. The result of `func` should be in the same format as bind$.

  Example:

    (code$ :seq '(require my-ns.core) '(fn [args] ...) ['c 'd])

  See also: pigpen.core.op/project$, pigpen.core.op/projection-func$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L66">Source</a></div></div><div class="public" id="var-concat%24"><h3>concat$</h3><div class="usage"><code>(concat$ opts ancestors)</code></div><pre class="doc">Inputs: [opts ancestors]
  Returns: (s/either m/Concat$ m/Op)

  Concatenates the set of ancestor relations together. The fields produced by
the concat operation are the fields of the first relation.

  Example:

    (concat$ {} [relation1 relation2])

  See also: pigpen.core.op/distinct$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L438">Source</a></div></div><div class="public" id="var-distinct%24"><h3>distinct$</h3><div class="usage"><code>(distinct$ opts relation)</code></div><pre class="doc">Inputs: [opts relation]
Returns: m/Distinct$

Returns the distinct values in relation.

Example:

  (distinct$ {} relation)

See also: pigpen.core.op/concat$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L425">Source</a></div></div><div class="public" id="var-filter-%3Ebind"><h3>filter-&gt;bind</h3><div class="usage"><code>(filter-&gt;bind f)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Takes a filter-style function (one that takes a single input and returns a
boolean output) and returns a bind function that performs the same logic.

  Example:

    (filter-&gt;bind (fn [x] (even? x)))

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L68">Source</a></div></div><div class="public" id="var-group%24"><h3>group$</h3><div class="usage"><code>(group$ field-dispatch join-types opts ancestors)</code></div><pre class="doc">Inputs: [field-dispatch join-types opts ancestors]
  Returns: m/Group$

  Performs a cogroup on the ancestors provided. The parameter `field-dispatch`
should be one of the following, and produces the following output fields:

  :group - [group r0/key r0/value ... rN/key rN/value]
  :join  - [r0/key r0/value ... rN/key rN/value]
  :set   - [r0/value ... rN/value]

The parameter `join-types` is a vector of keywords (:required or :optional)
specifying if each relation is required or optional. The length of join-types
must match the number of relations passed.

  Example:

    (group$
      :group
      [:required :optional]
      {}
      [relation1 relation2])

In this example, the operation performs a cogroup on relation1 and relation2.
The `:group` field-dispatch means that both of those relations will provide a
field with fields `key` and `value`, and the operation will add a `group` field.
The first relation is marked as required and the second is optional.

  See also: pigpen.core.op/join$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L489">Source</a></div></div><div class="public" id="var-indexed-field-selector-%3Ebind"><h3>indexed-field-selector-&gt;bind</h3><div class="usage"><code>(indexed-field-selector-&gt;bind n f)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Selects the first n fields and projects them as fields. The input relation
should have a single field, which is sequential. Applies f to the remaining args.

  Example:

    (indexed-field-selector-&gt;bind 2 pr-str)

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L127">Source</a></div></div><div class="public" id="var-join%24"><h3>join$</h3><div class="usage"><code>(join$ field-dispatch join-types opts ancestors)</code></div><pre class="doc">Inputs: [field-dispatch join-types opts ancestors]
  Returns: m/Join$

  Performs a join on the ancestors provided. The parameter `field-dispatch`
should be one of the following, and produces the following output fields:

  :group - [group r0/key r0/value ... rN/key rN/value]
  :join  - [r0/key r0/value ... rN/key rN/value]
  :set   - [r0/value ... rN/value]

The parameter `join-types` is a vector of keywords (:required or :optional)
specifying if each relation is required or optional. The length of join-types
must match the number of relations passed.

  Example:

    (join$
      :join
      [:required :optional]
      {}
      [relation1 relation2])

In this example, the operation performs a join on relation1 and relation2.
The `:join` field-dispatch means that both of those relations will provide a
field with fields `key` and `value`. The first relation is marked as required
and the second is optional.

  See also: pigpen.core.op/group$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L526">Source</a></div></div><div class="public" id="var-key-selector-%3Ebind"><h3>key-selector-&gt;bind</h3><div class="usage"><code>(key-selector-&gt;bind f)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Creates a key-selector function based on `f`. The resulting bind function
returns a tuple of [(f x) x]. This is generally used to separate a key for
subsequent use in a sort, group, or join.

  Example:

    (key-selector-&gt;bind (fn [x] (:foo x)))

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L88">Source</a></div></div><div class="public" id="var-keyword-field-selector-%3Ebind"><h3>keyword-field-selector-&gt;bind</h3><div class="usage"><code>(keyword-field-selector-&gt;bind fields)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Selects a set of fields from a map and projects them as native fields. The
bind function takes a single arg, which is a map with keyword keys. The
parameter `fields` is a sequence of keywords to select. The input relation
should have a single field that is a map value.

  Example:

    (keyword-field-selector-&gt;bind [:foo :bar :baz])

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L107">Source</a></div></div><div class="public" id="var-load%24"><h3>load$</h3><div class="usage"><code>(load$ location storage fields opts)</code></div><pre class="doc">Inputs: [location storage fields opts]
  Returns: m/Load$

  Load the data specified by `location`, a string. The parameter `storage` is a
keyword such as :string, :parquet, or :avro that specifies the type of storage
to use. Each platform is responsible for dispatching on storage as appropriate.
The parameters `fields` and `opts` specify what fields this will produce and any
options to the command.

  Example:

    (load$ &quot;input.tsv&quot; :string '[value] {})

  See also: pigpen.core.op/store$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L96">Source</a></div></div><div class="public" id="var-map-%3Ebind"><h3>map-&gt;bind</h3><div class="usage"><code>(map-&gt;bind f)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Takes a map-style function (one that takes a single input and returns a
single output) and returns a bind function that performs the same logic.

  Example:

    (map-&gt;bind (fn [x] (* x x)))

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L32">Source</a></div></div><div class="public" id="var-mapcat-%3Ebind"><h3>mapcat-&gt;bind</h3><div class="usage"><code>(mapcat-&gt;bind f)</code></div><pre class="doc">For use with pigpen.core.op/bind$

Takes a mapcat-style function (one that takes a single input and returns zero
to many outputs) and returns a bind function that performs the same logic.

  Example:

    (mapcat-&gt;bind (fn [x] (seq x)))

  See also: pigpen.core.op/bind$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/runtime.clj#L50">Source</a></div></div><div class="public" id="var-noop%24"><h3>noop$</h3><div class="usage"><code>(noop$ opts relation)</code></div><pre class="doc">Inputs: [opts relation]
Returns: m/NoOp$

A no-op command. This is used to introduce a unique id for a command.

Example:

  (noop$ {} relation)</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L570">Source</a></div></div><div class="public" id="var-project%24"><h3>project$</h3><div class="usage"><code>(project$ projections opts relation)</code></div><pre class="doc">Inputs: [projections opts relation]
  Returns: m/Project$

  Used to manipulate the fields of a relation, either by aliasing them or
applying functions to them. Usually you want bind$ instead of project$, as
PigPen will compile many of the former into one of the latter.

  Example:

    (project$
      [(projection-field$ 'a 'b)
       (projection-func$ 'e
         (code$ :seq
                '(require my-ns.core)
                '(fn [args] ...)
                ['c 'd]))]
      {}
      relation)

In the example above, we apply two operations to the input relation. First, we
alias the input field 'a as 'b. Second, we apply the user code specified by
code$ to the fields 'c and 'd to produce the field 'e. This implies that the
input relation has three fields, 'a, 'c, and 'd, and that the output fields of
this relation are 'b and 'e. If multiple projections are provided that flatten
results, the cross product of those is returned.

  See also: pigpen.core.op/projection-field$, pigpen.core.op/projection-func$,
            pigpen.core.op/code$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L243">Source</a></div></div><div class="public" id="var-projection-field%24"><h3>projection-field$</h3><div class="usage"><code>(projection-field$ field)</code><code>(projection-field$ field alias)</code><code>(projection-field$ field alias flatten)</code></div><pre class="doc">Project a single field into another, optionally providing an alias for the
new field. If an alias is not specified, the input field name is used. If the
field represents a collection, specify `flatten` as true to flatten the values
of the field into individual records.

  Examples:

    (projection-field$ 'a)         ;; copy the field a as a
    (projection-field$ 'a 'b)      ;; copy the field a as b
    (projection-field$ 'a 'b true) ;; copy the field a as b and flatten a

  See also: pigpen.core.op/project$, pigpen.core.op/projection-func$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L184">Source</a></div></div><div class="public" id="var-projection-func%24"><h3>projection-func$</h3><div class="usage"><code>(projection-func$ alias code)</code><code>(projection-func$ alias flatten code)</code></div><pre class="doc">Inputs: ([alias code :- m/CodeExpr] [alias flatten code :- m/CodeExpr])

  Apply code to a set of fields, optionally flattening the result. See code$
for details regarding how to express user code.

  Examples:

    (projection-func$ 'a (code$ ...))      ;; scalar result
    (projection-func$ 'a (code$ ...) true) ;; flatten the result collection

  See also: pigpen.core.op/code$, pigpen.core.op/project$,
            pigpen.core.op/projection-field$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L210">Source</a></div></div><div class="public" id="var-rank%24"><h3>rank$</h3><div class="usage"><code>(rank$ opts relation)</code></div><pre class="doc">Inputs: [opts relation]
  Returns: m/Rank$

  Rank the input relation. Adds a new field ('index), a long, to the fields of
the input relation.

  Example:

    (rank$ {} relation)

  See also: pigpen.core.op/sort$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L357">Source</a></div></div><div class="public" id="var-reduce%24"><h3>reduce$</h3><div class="usage"><code>(reduce$ opts relation)</code></div><pre class="doc">Inputs: [opts relation]
  Returns: m/Reduce$

  Reduce the entire relation into a single recrod that is the collection of all
records.

  Example:

    (reduce$ {} relation)

  See also: pigpen.core.op/group$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L462">Source</a></div></div><div class="public" id="var-return%24"><h3>return$</h3><div class="usage"><code>(return$ fields data)</code></div><pre class="doc">Inputs: [fields data]
  Returns: m/Return$

  Return the data as a PigPen relation. The parameter `fields` specifies what
fields the data will contain.

  Example:

    (return$ ['value] [{'value 42} {'value 37}])

  See also: pigpen.core.op/load$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L160">Source</a></div></div><div class="public" id="var-sample%24"><h3>sample$</h3><div class="usage"><code>(sample$ p opts relation)</code></div><pre class="doc">Inputs: [p opts relation]
Returns: m/Sample$

Samples the input relation at percentage p, where (&lt;= 0.0 p 1.0).

Example:

  (sample$ 0.5 {} relation)

See also: pigpen.core.op/take$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L408">Source</a></div></div><div class="public" id="var-sort%24"><h3>sort$</h3><div class="usage"><code>(sort$ key comp opts relation)</code></div><pre class="doc">Inputs: [key comp opts relation]
  Returns: m/Sort$

  Sort the data in relation. The parameter `key` specifies the field that
should be used to sort the data. The sort field should be a native type; not
serialized. `comp` is either :asc or :desc.

  Example:

    (sort$ 'key :asc {} relation)</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L340">Source</a></div></div><div class="public" id="var-store%24"><h3>store$</h3><div class="usage"><code>(store$ location storage opts relation)</code></div><pre class="doc">Inputs: [location storage opts relation]
  Returns: m/Store$

  Store the data specified by `location`, a string. The parameter `storage` is
a keyword such as :string, :parquet, or :avro that specifies the type of storage
to use. Each platform is responsible for dispatching on storage as appropriate.
The parameter `opts` specify any options to the command. This command can only
be passed to store-many$ commands or to platform generation commands.

  Example:

    (store$ &quot;output.tsv&quot; :string {} relation)

  See also: pigpen.core.op/load$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L121">Source</a></div></div><div class="public" id="var-store-many%24"><h3>store-many$</h3><div class="usage"><code>(store-many$ outputs)</code></div><pre class="doc">Inputs: [outputs]
  Returns: m/StoreMany$

  Combines multiple store$ commands into a single command. This command can
only be passed to other store-many$ commands or to platform generation commands.

  Example:

    (store-many$ [(store$ &quot;output1.tsv&quot; :string {} relation1)
                  (store$ &quot;output2.tsv&quot; :string {} relation2)])

  See also: pigpen.core.op/store$</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L144">Source</a></div></div><div class="public" id="var-take%24"><h3>take$</h3><div class="usage"><code>(take$ n opts relation)</code></div><pre class="doc">Inputs: [n opts relation]
Returns: m/Take$

Returns the first n records from relation.

Example:

  (take$ 100 {} relation)

See also: pigpen.core.op/sample$</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/raw.clj#L393">Source</a></div></div></div></body></html>