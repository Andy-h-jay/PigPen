<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>pigpen.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Pigpen</span> <span class="project-version">0.3.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pigpen</span></div></div></li><li class="depth-2 branch"><a href="pigpen.avro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>avro</span></div></a></li><li class="depth-2 branch"><a href="pigpen.cascading.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cascading</span></div></a></li><li class="depth-2 current"><a href="pigpen.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="pigpen.core.fn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fn</span></div></a></li><li class="depth-3"><a href="pigpen.core.op.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>op</span></div></a></li><li class="depth-2 branch"><a href="pigpen.fold.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>fold</span></div></a></li><li class="depth-2 branch"><a href="pigpen.parquet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parquet</span></div></a></li><li class="depth-2 branch"><a href="pigpen.pig.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pig</span></div></a></li><li class="depth-2 branch"><a href="pigpen.rx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rx</span></div></a></li><li class="depth-2"><a href="pigpen.viz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>viz</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="pigpen.core.html#var-cogroup"><div class="inner"><span>cogroup</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-constantly"><div class="inner"><span>constantly</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-difference-multiset"><div class="inner"><span>difference-multiset</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-distinct"><div class="inner"><span>distinct</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-dump"><div class="inner"><span>dump</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-filter-by"><div class="inner"><span>filter-by</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-fold"><div class="inner"><span>fold</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-intersection-multiset"><div class="inner"><span>intersection-multiset</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-into"><div class="inner"><span>into</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-keys-fn"><div class="inner"><span>keys-fn</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-clj"><div class="inner"><span>load-clj</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-csv"><div class="inner"><span>load-csv</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-json"><div class="inner"><span>load-json</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-lazy"><div class="inner"><span>load-lazy</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-string"><div class="inner"><span>load-string</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-load-tsv"><div class="inner"><span>load-tsv</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-map-indexed"><div class="inner"><span>map-indexed</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-mapcat"><div class="inner"><span>mapcat</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-reduce"><div class="inner"><span>reduce</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-remove"><div class="inner"><span>remove</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-remove-by"><div class="inner"><span>remove-by</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-return"><div class="inner"><span>return</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-sort"><div class="inner"><span>sort</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-sort-by"><div class="inner"><span>sort-by</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-store-clj"><div class="inner"><span>store-clj</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-store-json"><div class="inner"><span>store-json</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-store-many"><div class="inner"><span>store-many</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-store-string"><div class="inner"><span>store-string</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-store-tsv"><div class="inner"><span>store-tsv</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-take"><div class="inner"><span>take</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="pigpen.core.html#var-union-multiset"><div class="inner"><span>union-multiset</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">pigpen.core</h1><div class="doc"><pre class="plaintext">The core PigPen operations. These are the primary functions that you use to
build a PigPen query.</pre></div><div class="public anchor" id="var-cogroup"><h3>cogroup</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(cogroup selects f)</code><code>(cogroup selects f opts)</code></div><div class="doc"><pre class="plaintext">Joins many relations together by a common key. Each relation specifies a
key-selector function on which to join. A combiner function is applied to each
join key and all values from each relation that match that join key. This is
similar to join, without flattening the data. Optionally takes a map of options.

  Example:

    (pig/cogroup [(foo :on :a)
                  (bar :on :b, :type :required, :fold (fold/count))]
                 (fn [key foos bar-count] ...)
                 {:parallel 20})

In this example, foo and bar are other pig queries and :a and :b are the
key-selector functions for foo and bar, respectively. These can be any
functions - not just keywords. There can be more than two select clauses.
By default, a matching key value from eatch source relation is optional,
meaning that keys don't have to exist in all source relations to be part of the
output. To specify a relation as required, add 'required' to the select clause.
The third argument is a function used to consolidate matching key values. For
each uniqe key value, this function is called with the value of the key and all
values with that key from foo and bar. As such, foos and bars are both
collections. The last argument is an optional map of options. A fold function
can be specified to aggregate groupings in parallel. See pigpen.fold for more
info on fold functions.

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :join-nils - Whether nil keys from each relation should be treated as equal

  See also: pigpen.core/join, pigpen.core/group-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L316">view source</a></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(concat relations+)</code></div><div class="doc"><pre class="plaintext">Concatenates all relations provided. Does not guarantee any ordering of the
relations. Identical to pigpen.core/union-multiset.

  Example:

    (pig/concat
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 4 5]

  See also: pigpen.core/union, pigpen.core/distinct, pigpen.core/union-multiset</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L155">view source</a></div></div><div class="public anchor" id="var-constantly"><h3>constantly</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(constantly data)</code></div><div class="doc"><pre class="plaintext">Returns a function that takes any number of arguments and returns a constant
set of data as if it had been loaded by pigpen. This is useful for testing,
but not supported in generated scripts. The parameter 'data' must be a sequence.
The values of 'data' can be any clojure type.

  Example:

    (pig/constantly [1 2 3])
    (pig/constantly [{:a 123} {:b 456}])

  See also: pigpen.core/return</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L284">view source</a></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(difference opts? relations+)</code></div><div class="doc"><pre class="plaintext">Performs a set difference on all relations provided and returns the distinct
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/difference
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2])
      (pig/return [3]))

    =&gt; [4 5]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/difference-multiset, pigpen.core/intersection</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L247">view source</a></div></div><div class="public anchor" id="var-difference-multiset"><h3>difference-multiset</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(difference-multiset opts? relations+)</code></div><div class="doc"><pre class="plaintext">Performs a multiset difference on all relations provided and returns all
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/difference-multiset
      (pig/return [1 2 2 3 3 3 3 4 5])
      (pig/return [1 2 3])
      (pig/return [1 2 3]))

    =&gt; [3 3 4 5]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/difference, pigpen.core/intersection</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L271">view source</a></div></div><div class="public anchor" id="var-distinct"><h3>distinct</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(distinct relation)</code><code>(distinct opts relation)</code></div><div class="doc"><pre class="plaintext">Returns a relation with the distinct values of relation. Optionally takes a
map of options.

  Example:

    (pig/distinct foo)
    (pig/distinct {:parallel 20} foo)

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :partition-by - A partition function to use. Should take the form:
      (fn [n key] (mod (hash key) n)) Where n is the number of partitions and
      key is the key to partition.

  See also: pigpen.core/union, pigpen.core/union-multiset, pigpen.core/filter</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L104">view source</a></div></div><div class="public anchor" id="var-dump"><h3>dump</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(dump query)</code><code>(dump opts query)</code></div><div class="doc"><pre class="plaintext">Executes a script locally and returns the resulting values as a clojure
sequence. This command is very useful for unit tests.

  Example:

    (-&gt;&gt;
      (pig/load-clj "input.clj")
      (pig/map inc)
      (pig/filter even?)
      (pig/dump)
      (clojure.core/map #(* % %))
      (clojure.core/filter even?))

    (deftest test-script
      (is (= (-&gt;&gt;
               (pig/load-clj "input.clj")
               (pig/map inc)
               (pig/filter even?)
               (pig/dump))
             [2 4 6])))

  Note: pig/store commands return the output data
        pig/store-many commands merge their results

  Note: The original rx pigpen.core/dump command is now pigpen.rx/dump. This
        implementation uses lazy seqs instead.</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/local.clj#L151">view source</a></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(filter pred relation)</code></div><div class="doc"><pre class="plaintext">Returns a relation that only contains the items for which (pred item)
returns true.

  Example:

    (pig/filter even? foo)
    (pig/filter (fn [x] (even? (* x x))) foo)

  See also: pigpen.core/remove, pigpen.core/take, pigpen.core/sample,
            pigpen.core/distinct, pigpen.core/filter-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/filter.clj#L51">view source</a></div></div><div class="public anchor" id="var-filter-by"><h3>filter-by</h3><h4 class="type">macro</h4><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(filter-by key-selector keys relation)</code><code>(filter-by key-selector keys opts relation)</code></div><div class="doc"><pre class="plaintext">Filters a relation by the keys in another relation. The key-selector function
is applied to each element of relation. If the resulting key is present in keys,
the value is kept. Otherwise it is dropped. nils are dropped or preserved based
on whether there is a nil value present in keys. This operation is referred to
as a semi-join in relational databases.

  Example:

    (let [keys (pig/return [1 3 5])
          data (pig/return [{:k 1, :v "a"}
                            {:k 2, :v "b"}
                            {:k 3, :v "c"}
                            {:k 4, :v "d"}
                            {:k 5, :v "e"}])]
      (pig/filter-by :k keys data))

    =&gt; (pig/dump *1)
    [{:k 1, :v "a"}
     {:k 3, :v "c"}
     {:k 5, :v "e"}]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: keys must be distinct before this is used or you will get duplicate values.
  Note: Unlike filter, this joins relation with keys and can be potentially expensive.

  See also: pigpen.core/filter, pigpen.core/remove-by, pigpen.core/intersection</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L403">view source</a></div></div><div class="public anchor" id="var-fold"><h3>fold</h3><h4 class="type">macro</h4><h4 class="added">added in 0.2.0</h4><div class="usage"><code>(fold reducef relation)</code><code>(fold combinef reducef relation)</code></div><div class="doc"><pre class="plaintext">Computes a parallel reduce of the relation. This is done in multiple stages
using reducef and combinef. First, combinef is called with no args to produce a
seed value. Then, reducef reduces portions of the data using that seed value.
Finally, combinef is used to reduce each of the intermediate values. If combinef
is not specified, reducef is used for both. Fold functions defined using
pigpen.fold/fold-fn can also be used.

  Example:

    (pig/fold + foo)
    (pig/fold + (fn [acc _] (inc acc)) foo)
    (pig/fold (fold/fold-fn + (fn [acc _] (inc acc))) foo)

  See pigpen.fold for more info on fold functions.

  Note: Folding an empty sequence will always return an empty sequence:

		=&gt; (-&gt;&gt;
		     (pig/return [])
		     (pig/fold (fold/count))
		     (pig/dump))
		[]</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L280">view source</a></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(group-by key-selector relation)</code><code>(group-by key-selector opts relation)</code></div><div class="doc"><pre class="plaintext">Groups relation by the result of calling (key-selector item) for each item.
This produces a sequence of map entry values, similar to using seq with a
map. Each value will be a lazy sequence of the values that match key.
Optionally takes a map of options, including :parallel and :fold.

  Example:

    (pig/group-by :a foo)
    (pig/group-by count {:parallel 20} foo)

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/cogroup

  See pigpen.fold for more info on :fold options.</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L195">view source</a></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(intersection opts? relations+)</code></div><div class="doc"><pre class="plaintext">Performs an intersection on all relations provided and returns the distinct
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/intersection
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 3]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/intersection-multiset, pigpen.core/difference</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L199">view source</a></div></div><div class="public anchor" id="var-intersection-multiset"><h3>intersection-multiset</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(intersection-multiset opts? relations+)</code></div><div class="doc"><pre class="plaintext">Performs a multiset intersection on all relations provided and returns all
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/intersection-multiset
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 2 3 3]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/intersection, pigpen.core/difference</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L223">view source</a></div></div><div class="public anchor" id="var-into"><h3>into</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(into to relation)</code></div><div class="doc"><pre class="plaintext">Returns a new relation with all values from relation conjoined onto to.

Note: This operation uses a single reducer and won't work for large datasets.

See also: pigpen.core/reduce

Note: Reducing an empty sequence will always return an empty sequence:

=&gt; (-&gt;&gt;
     (pig/return [])
     (pig/into {})
     (pig/dump))
[]</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L225">view source</a></div></div><div class="public anchor" id="var-join"><h3>join</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(join selects f)</code><code>(join selects f opts)</code></div><div class="doc"><pre class="plaintext">Joins many relations together by a common key. Each relation specifies a
key-selector function on which to join. A function is applied to each join
key and each pair of values from each relation that match that join key.
Optionally takes a map of options.

  Example:

    (pig/join [(foo :on :a)
               (bar :on :b :type :optional)]
              (fn [f b] ...)
              {:parallel 20})

In this example, foo and bar are other pig queries and :a and :b are the
key-selector functions for foo and bar, respectively. These can be any
functions - not just keywords. There can be more than two select clauses.
By default, a matching key value from eatch source relation is required,
meaning that they must exist in all source relations to be part of the output.
To specify a relation as optional, add 'optional' to the select clause. The
third argument is a function used to consolidate matching key values. For each
uniqe key value, this function is called with each set of values from the cross
product of each source relation. By default, this does a standard inner join.
Use 'optional' to do outer joins. The last argument is an optional map of
options.

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :join-nils - Whether nil keys from each relation should be treated as equal

  See also: pigpen.core/cogroup, pigpen.core/union</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L360">view source</a></div></div><div class="public anchor" id="var-keys-fn"><h3>keys-fn</h3><h4 class="type">macro</h4><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(keys-fn &amp; body)</code></div><div class="doc"><pre class="plaintext">Creates a named anonymous function. Useful as a terse substitute for keys
destructuring.

Similar to an anonymous function, which uses positional names for arg:

  #(assoc %1 :foo %2 :bar %3)

`keys-fn` uses named variables that are keys in the input map:

  (keys-fn
    (assoc %
      :foo-copy %foo
      :bar-x-2  (* %bar 2)))

To compare, this is the same function using keys destructuring:

  (fn [{:keys [foo bar], :as value}]
    (assoc value
      :foo-copy foo
      :bar-x-2  (* bar 2)))

When using a large number of destructured variables, this can make a noticeable
difference in code size and readability. This macro simply re-writes the first
form into the second.</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/extensions/core.clj#L108">view source</a></div></div><div class="public anchor" id="var-load-clj"><h3>load-clj</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(load-clj location)</code></div><div class="doc"><pre class="plaintext">Loads clojure data from a file. Each line should contain one value and will
be parsed using clojure.edn/read-string into a value.

  Example:

    (pig/load-clj "input.clj")

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-json

  See: <a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a></pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L106">view source</a></div></div><div class="public anchor" id="var-load-csv"><h3>load-csv</h3><h4 class="added">added in 0.2.12</h4><div class="usage"><code>(load-csv location)</code><code>(load-csv location separator quotor)</code></div><div class="doc"><pre class="plaintext">Loads data from a csv file. Each line is returned as a vector of strings,
split according to RFC4180(*). The default separator is \, and quote is \".

  Note: Newlines within cells are not supported due to line-based splitting of files.

  Example:

    (pig/load-csv "input.csv")
    (pig/load-tsv "input.csv" \, \")

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-clj, pigpen.core/load-json</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L88">view source</a></div></div><div class="public anchor" id="var-load-json"><h3>load-json</h3><h4 class="type">macro</h4><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(load-json location)</code><code>(load-json location opts)</code></div><div class="doc"><pre class="plaintext">Loads json data from a file. Each line should contain one value and will be
parsed using clojure.data.json/read-str into a value. Options can be passed to
read-str as a map. The default options used are {:key-fn keyword}.

  Example:

    (pig/load-json "input.json")

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-clj</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L122">view source</a></div></div><div class="public anchor" id="var-load-lazy"><h3>load-lazy</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(load-lazy location)</code><code>(load-lazy location delimiter)</code></div><div class="doc"><pre class="plaintext">Loads data from a tsv file. Each line is returned as a lazy seq, split by
the specified delimiter. The default delimiter is \t.

  See also: pigpen.core/load-tsv</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L140">view source</a></div></div><div class="public anchor" id="var-load-string"><h3>load-string</h3><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(load-string location)</code></div><div class="doc"><pre class="plaintext">Loads data from a file. Each line is returned as a string.

Example:

  (pig/load-string "input.txt")

See also: pigpen.core/load-tsv, pigpen.core/load-clj, pigpen.core/load-json</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L59">view source</a></div></div><div class="public anchor" id="var-load-tsv"><h3>load-tsv</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(load-tsv location)</code><code>(load-tsv location delimiter)</code></div><div class="doc"><pre class="plaintext">Loads data from a tsv file. Each line is returned as a vector of strings,
split by the specified regex delimiter. The default delimiter is #"\t".

  Example:

    (pig/load-tsv "input.tsv")
    (pig/load-tsv "input.csv" #",")

  See also: pigpen.core/load-string, pigpen.core/load-clj, pigpen.core/load-json</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L72">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(map f relation)</code></div><div class="doc"><pre class="plaintext">Returns a relation of f applied to every item in the source relation.
Function f should be a function of one argument.

  Example:

    (pig/map inc foo)
    (pig/map (fn [x] (* x x)) foo)

  Note: Unlike clojure.core/map, pigpen.core/map takes only one relation. This
is due to the fact that there is no defined order in pigpen. See pig/join,
pig/cogroup, and pig/union for combining sets of data.

  See also: pigpen.core/mapcat, pigpen.core/map-indexed, pigpen.core/join,
            pigpen.core/cogroup, pigpen.core/union</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L59">view source</a></div></div><div class="public anchor" id="var-map-indexed"><h3>map-indexed</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(map-indexed f relation)</code><code>(map-indexed f opts relation)</code></div><div class="doc"><pre class="plaintext">Returns a relation of applying f to the the index and value of every item in
the source relation. Function f should be a function of two arguments: the index
and the value. If you require sequential ids, use option {:dense true}.

  Example:

    (pig/map-indexed (fn [i x] (* i x)) foo)
    (pig/map-indexed vector {:dense true} foo)

  Options:

    :dense - force sequential ids (pig only)

  Note: If you require sorted data, use sort or sort-by immediately before
        this command.

  Note: Pig will assign the same index to any equal values, regardless of how
        many times they appear.

  Note: The cascading implementation of map-indexed uses a single reducer

  See also: pigpen.core/sort, pigpen.core/sort-by, pigpen.core/map, pigpen.core/mapcat</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L135">view source</a></div></div><div class="public anchor" id="var-mapcat"><h3>mapcat</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(mapcat f relation)</code></div><div class="doc"><pre class="plaintext">Returns the result of applying concat, or flattening, the result of applying
f to each item in relation. Thus f should return a collection.

  Example:

    (pig/mapcat (fn [x] [(dec x) x (inc x)]) foo)

  See also: pigpen.core/map, pigpen.core/map-indexed</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L99">view source</a></div></div><div class="public anchor" id="var-reduce"><h3>reduce</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(reduce f relation)</code><code>(reduce f val relation)</code></div><div class="doc"><pre class="plaintext">Reduce all items in relation into a single value. Follows semantics of
clojure.core/reduce. If a sequence is returned, it is kept as a single value
for further processing.

  Example:

    (pig/reduce + foo)
    (pig/reduce conj [] foo)

  Note: This operation uses a single reducer and won't work for large datasets.
        Use pig/fold to do a parallel reduce.

  See also: pigpen.core/fold, pigpen.core/into

  Note: Reducing an empty sequence will always return an empty sequence:

		=&gt; (-&gt;&gt;
		     (pig/return [])
		     (pig/reduce +)
		     (pig/dump))
		[]</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L247">view source</a></div></div><div class="public anchor" id="var-remove"><h3>remove</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(remove pred relation)</code></div><div class="doc"><pre class="plaintext">Returns a relation without items for which (pred item) returns true.

Example:

  (pig/remove even? foo)
  (pig/remove (fn [x] (even? (* x x))) foo)

See also: pigpen.core/filter, pigpen.core/take, pigpen.core/sample,
          pigpen.core/distinct, pigpen.core/remove-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/filter.clj#L67">view source</a></div></div><div class="public anchor" id="var-remove-by"><h3>remove-by</h3><h4 class="type">macro</h4><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(remove-by key-selector keys relation)</code><code>(remove-by key-selector keys opts relation)</code></div><div class="doc"><pre class="plaintext">Filters a relation by the keys in another relation. The key-selector function
is applied to each element of relation. If the resulting key is _not_ present in
keys, the value is kept. Otherwise it is dropped. nils are dropped or preserved
based on whether there is a nil value present in keys. This operation is
referred to as an anti-join in relational databases.

  Example:

    (let [keys (pig/return [1 3 5])
          data (pig/return [{:k 1, :v "a"}
                            {:k 2, :v "b"}
                            {:k 3, :v "c"}
                            {:k 4, :v "d"}
                            {:k 5, :v "e"}])]
      (pig/remove-by :k keys data))

    =&gt; (pig/dump *1)
    [{:k 2, :v "b"}
     {:k 4, :v "d"}]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: Unlike remove, this joins relation with keys and can be potentially expensive.

  See also: pigpen.core/remove, pigpen.core/filter-by, pigpen.core/difference</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L443">view source</a></div></div><div class="public anchor" id="var-return"><h3>return</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(return data)</code></div><div class="doc"><pre class="plaintext">Returns a constant set of data as a pigpen relation. This is useful for
testing, but not supported in generated scripts. The parameter 'data' must be a
sequence. The values of 'data' can be any clojure type.

  Example:

    (pig/constantly [1 2 3])
    (pig/constantly [{:a 123} {:b 456}])

  See also: pigpen.core/constantly</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L265">view source</a></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(sample p relation)</code></div><div class="doc"><pre class="plaintext">Samples the input records by p percentage. This is non-deterministic;
different values may selected on subsequent runs. p should be a value
between 0.0 and 1.0

  Example:

    (pig/sample 0.01 foo)

  Note: This is potentially an expensive operation when run locally.

  See also: pigpen.core/filter, pigpen.core/take</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/filter.clj#L97">view source</a></div></div><div class="public anchor" id="var-sort"><h3>sort</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(sort relation)</code><code>(sort comp relation)</code><code>(sort comp opts relation)</code></div><div class="doc"><pre class="plaintext">Sorts the data with an optional comparator. Takes an optional map of options.

Example:

  (pig/sort foo)
  (pig/sort :desc foo)
  (pig/sort :desc {:parallel 20} foo)

Notes:
  The default comparator is :asc (ascending sort order).
  Only :asc and :desc are supported comparators.
  The values must be primitive values (string, int, etc).
  Maps, vectors, etc are not supported.

Options:

  :parallel - The degree of parallelism to use (pig only)

Note: The cascading implementation of sort uses a single reducer

See also: pigpen.core/sort-by</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L190">view source</a></div></div><div class="public anchor" id="var-sort-by"><h3>sort-by</h3><h4 class="type">macro</h4><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(sort-by key-fn relation)</code><code>(sort-by key-fn comp relation)</code><code>(sort-by key-fn comp opts relation)</code></div><div class="doc"><pre class="plaintext">Sorts the data by the specified key-fn with an optional comparator. Takes an
optional map of options.

  Example:

    (pig/sort-by :a foo)
    (pig/sort-by #(count %) :desc foo)
    (pig/sort-by (fn [x] (* x x)) :desc {:parallel 20} foo)

  Notes:
    The default comparator is :asc (ascending sort order).
    Only :asc and :desc are supported comparators.
    The key-fn values must be primitive values (string, int, etc).
    Maps, vectors, etc are not supported.

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: The cascading implementation of sort-by uses a single reducer

  See also: pigpen.core/sort</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L219">view source</a></div></div><div class="public anchor" id="var-store-clj"><h3>store-clj</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(store-clj location relation)</code></div><div class="doc"><pre class="plaintext">Stores the relation into location using edn (clojure format). Each value is
written as a single line.

  Example:

    (pig/store-clj "output.clj" foo)

  See also: pigpen.core/store-string, pigpen.core/store-tsv, pigpen.core/store-json

  See: <a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a></pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L214">view source</a></div></div><div class="public anchor" id="var-store-json"><h3>store-json</h3><h4 class="type">macro</h4><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(store-json location relation)</code><code>(store-json location opts relation)</code></div><div class="doc"><pre class="plaintext">Stores the relation into location using clojure.data.json. Each value is
written as a single line. Options can be passed to write-str as a map.

  Example:

    (pig/store-json "output.json" foo)

  See also: pigpen.core/store-string, pigpen.core/store-tsv, pigpen.core/store-clj</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L230">view source</a></div></div><div class="public anchor" id="var-store-many"><h3>store-many</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(store-many outputs+)</code></div><div class="doc"><pre class="plaintext">Combines multiple store commands into a single script. This is not required
if you have a single output.

  Example:

    (pig/store-many
      (pig/store-tsv "foo.tsv" foo)
      (pig/store-clj "bar.clj" bar))

  Note: When run locally, this will merge the results of any source relations.</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L248">view source</a></div></div><div class="public anchor" id="var-store-string"><h3>store-string</h3><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(store-string location relation)</code></div><div class="doc"><pre class="plaintext">Stores the relation into location as a string. Each value is written as a
single line.

  Example:

    (pig/store-string "output.txt" foo)

  See also: pigpen.core/store-tsv, pigpen.core/store-clj, pigpen.core/store-json</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L182">view source</a></div></div><div class="public anchor" id="var-store-tsv"><h3>store-tsv</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(store-tsv location relation)</code><code>(store-tsv location delimiter relation)</code></div><div class="doc"><pre class="plaintext">Stores the relation into location as a tab-delimited file. Thus, each input
value must be sequential. Complex values are stored as edn (clojure format).
Single string values are not quoted. You may optionally pass a different delimiter.

  Example:

    (pig/store-tsv "output.tsv" foo)
    (pig/store-tsv "output.csv" "," foo)

  See also: pigpen.core/store-string, pigpen.core/store-clj, pigpen.core/store-json</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L196">view source</a></div></div><div class="public anchor" id="var-take"><h3>take</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(take n relation)</code></div><div class="doc"><pre class="plaintext">Limits the number of records to n items.

Example:

  (pig/take 200 foo)

Note: This is potentially an expensive operation when run on the server.

See also: pigpen.core/filter, pigpen.core/sample</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/filter.clj#L82">view source</a></div></div><div class="public anchor" id="var-union"><h3>union</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(union opts? relations+)</code></div><div class="doc"><pre class="plaintext">Performs a union on all relations provided and returns the distinct results.
Optionally takes a map of options as the first parameter.

  Example:

    (pig/union
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 3 4 5]

  Options:

    :parallel - the degree of parallelism to use (pig only)

  See also: pigpen.core/union-multiset, pigpen.core/distinct</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L127">view source</a></div></div><div class="public anchor" id="var-union-multiset"><h3>union-multiset</h3><h4 class="added">added in 0.1.0</h4><div class="usage"><code>(union-multiset relations+)</code></div><div class="doc"><pre class="plaintext">Performs a union on all relations provided and returns all results.
Identical to pigpen.core/concat.

  Example:

    (pig/union-multiset
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 4 5]

  See also: pigpen.core/union, pigpen.core/distinct, pigpen.core/concat</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/v0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L177">view source</a></div></div></div></body></html>