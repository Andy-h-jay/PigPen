<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>pigpen.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Pigpen 0.3.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="pigpen.core.html"><span>pigpen.core</span></a></li><li><a href="pigpen.core.fn.html"><span>pigpen.core.fn</span></a></li><li><a href="pigpen.core.op.html"><span>pigpen.core.op</span></a></li><li><a href="pigpen.fold.html"><span>pigpen.fold</span></a></li><li><a href="pigpen.rx.html"><span>pigpen.rx</span></a></li><li><a href="pigpen.pig.html"><span>pigpen.pig</span></a></li><li><a href="pigpen.cascading.html"><span>pigpen.cascading</span></a></li><li><a href="pigpen.parquet.html"><span>pigpen.parquet</span></a></li><li><a href="pigpen.avro.html"><span>pigpen.avro</span></a></li><li><a href="pigpen.viz.html"><span>pigpen.viz</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="pigpen.core.html#var-cogroup"><span>cogroup</span></a></li><li><a href="pigpen.core.html#var-concat"><span>concat</span></a></li><li><a href="pigpen.core.html#var-constantly"><span>constantly</span></a></li><li><a href="pigpen.core.html#var-difference"><span>difference</span></a></li><li><a href="pigpen.core.html#var-difference-multiset"><span>difference-multiset</span></a></li><li><a href="pigpen.core.html#var-distinct"><span>distinct</span></a></li><li><a href="pigpen.core.html#var-dump"><span>dump</span></a></li><li><a href="pigpen.core.html#var-filter"><span>filter</span></a></li><li><a href="pigpen.core.html#var-filter-by"><span>filter-by</span></a></li><li><a href="pigpen.core.html#var-fold"><span>fold</span></a></li><li><a href="pigpen.core.html#var-group-by"><span>group-by</span></a></li><li><a href="pigpen.core.html#var-intersection"><span>intersection</span></a></li><li><a href="pigpen.core.html#var-intersection-multiset"><span>intersection-multiset</span></a></li><li><a href="pigpen.core.html#var-into"><span>into</span></a></li><li><a href="pigpen.core.html#var-join"><span>join</span></a></li><li><a href="pigpen.core.html#var-keys-fn"><span>keys-fn</span></a></li><li><a href="pigpen.core.html#var-load-clj"><span>load-clj</span></a></li><li><a href="pigpen.core.html#var-load-csv"><span>load-csv</span></a></li><li><a href="pigpen.core.html#var-load-json"><span>load-json</span></a></li><li><a href="pigpen.core.html#var-load-lazy"><span>load-lazy</span></a></li><li><a href="pigpen.core.html#var-load-string"><span>load-string</span></a></li><li><a href="pigpen.core.html#var-load-tsv"><span>load-tsv</span></a></li><li><a href="pigpen.core.html#var-map"><span>map</span></a></li><li><a href="pigpen.core.html#var-map-indexed"><span>map-indexed</span></a></li><li><a href="pigpen.core.html#var-mapcat"><span>mapcat</span></a></li><li><a href="pigpen.core.html#var-reduce"><span>reduce</span></a></li><li><a href="pigpen.core.html#var-remove"><span>remove</span></a></li><li><a href="pigpen.core.html#var-remove-by"><span>remove-by</span></a></li><li><a href="pigpen.core.html#var-return"><span>return</span></a></li><li><a href="pigpen.core.html#var-sample"><span>sample</span></a></li><li><a href="pigpen.core.html#var-sort"><span>sort</span></a></li><li><a href="pigpen.core.html#var-sort-by"><span>sort-by</span></a></li><li><a href="pigpen.core.html#var-store-clj"><span>store-clj</span></a></li><li><a href="pigpen.core.html#var-store-json"><span>store-json</span></a></li><li><a href="pigpen.core.html#var-store-many"><span>store-many</span></a></li><li><a href="pigpen.core.html#var-store-string"><span>store-string</span></a></li><li><a href="pigpen.core.html#var-store-tsv"><span>store-tsv</span></a></li><li><a href="pigpen.core.html#var-take"><span>take</span></a></li><li><a href="pigpen.core.html#var-union"><span>union</span></a></li><li><a href="pigpen.core.html#var-union-multiset"><span>union-multiset</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>pigpen.core documentation</h2><pre class="doc">The core PigPen operations. These are the primary functions that you use to
build a PigPen query.</pre><div class="public" id="var-cogroup"><h3>cogroup</h3><h4 class="macro">macro</h4><div class="usage"><code>(cogroup selects f)</code><code>(cogroup selects f opts)</code></div><pre class="doc">Joins many relations together by a common key. Each relation specifies a
key-selector function on which to join. A combiner function is applied to each
join key and all values from each relation that match that join key. This is
similar to join, without flattening the data. Optionally takes a map of options.

  Example:

    (pig/cogroup [(foo :on :a)
                  (bar :on :b, :type :required, :fold (fold/count))]
                 (fn [key foos bar-count] ...)
                 {:parallel 20})

In this example, foo and bar are other pig queries and :a and :b are the
key-selector functions for foo and bar, respectively. These can be any
functions - not just keywords. There can be more than two select clauses.
By default, a matching key value from eatch source relation is optional,
meaning that keys don't have to exist in all source relations to be part of the
output. To specify a relation as required, add 'required' to the select clause.
The third argument is a function used to consolidate matching key values. For
each uniqe key value, this function is called with the value of the key and all
values with that key from foo and bar. As such, foos and bars are both
collections. The last argument is an optional map of options. A fold function
can be specified to aggregate groupings in parallel. See pigpen.fold for more
info on fold functions.

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :join-nils - Whether nil keys from each relation should be treated as equal

  See also: pigpen.core/join, pigpen.core/group-by</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L316">Source</a></div></div><div class="public" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat relations+)</code></div><pre class="doc">Concatenates all relations provided. Does not guarantee any ordering of the
relations. Identical to pigpen.core/union-multiset.

  Example:

    (pig/concat
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 4 5]

  See also: pigpen.core/union, pigpen.core/distinct, pigpen.core/union-multiset</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L155">Source</a></div></div><div class="public" id="var-constantly"><h3>constantly</h3><div class="usage"><code>(constantly data)</code></div><pre class="doc">Returns a function that takes any number of arguments and returns a constant
set of data as if it had been loaded by pigpen. This is useful for testing,
but not supported in generated scripts. The parameter 'data' must be a sequence.
The values of 'data' can be any clojure type.

  Example:

    (pig/constantly [1 2 3])
    (pig/constantly [{:a 123} {:b 456}])

  See also: pigpen.core/return</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L284">Source</a></div></div><div class="public" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference opts? relations+)</code></div><pre class="doc">Performs a set difference on all relations provided and returns the distinct
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/difference
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2])
      (pig/return [3]))

    =&gt; [4 5]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/difference-multiset, pigpen.core/intersection</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L247">Source</a></div></div><div class="public" id="var-difference-multiset"><h3>difference-multiset</h3><div class="usage"><code>(difference-multiset opts? relations+)</code></div><pre class="doc">Performs a multiset difference on all relations provided and returns all
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/difference-multiset
      (pig/return [1 2 2 3 3 3 3 4 5])
      (pig/return [1 2 3])
      (pig/return [1 2 3]))

    =&gt; [3 3 4 5]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/difference, pigpen.core/intersection</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L271">Source</a></div></div><div class="public" id="var-distinct"><h3>distinct</h3><h4 class="macro">macro</h4><div class="usage"><code>(distinct relation)</code><code>(distinct opts relation)</code></div><pre class="doc">Returns a relation with the distinct values of relation. Optionally takes a
map of options.

  Example:

    (pig/distinct foo)
    (pig/distinct {:parallel 20} foo)

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :partition-by - A partition function to use. Should take the form:
      (fn [n key] (mod (hash key) n)) Where n is the number of partitions and
      key is the key to partition.

  See also: pigpen.core/union, pigpen.core/union-multiset, pigpen.core/filter</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L104">Source</a></div></div><div class="public" id="var-dump"><h3>dump</h3><div class="usage"><code>(dump query)</code><code>(dump opts query)</code></div><pre class="doc">Executes a script locally and returns the resulting values as a clojure
sequence. This command is very useful for unit tests.

  Example:

    (-&gt;&gt;
      (pig/load-clj &quot;input.clj&quot;)
      (pig/map inc)
      (pig/filter even?)
      (pig/dump)
      (clojure.core/map #(* % %))
      (clojure.core/filter even?))

    (deftest test-script
      (is (= (-&gt;&gt;
               (pig/load-clj &quot;input.clj&quot;)
               (pig/map inc)
               (pig/filter even?)
               (pig/dump))
             [2 4 6])))

  Note: pig/store commands return the output data
        pig/store-many commands merge their results

  Note: The original rx pigpen.core/dump command is now pigpen.rx/dump. This
        implementation uses lazy seqs instead.</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/local.clj#L151">Source</a></div></div><div class="public" id="var-filter"><h3>filter</h3><h4 class="macro">macro</h4><div class="usage"><code>(filter pred relation)</code></div><pre class="doc">Returns a relation that only contains the items for which (pred item)
returns true.

  Example:

    (pig/filter even? foo)
    (pig/filter (fn [x] (even? (* x x))) foo)

  See also: pigpen.core/remove, pigpen.core/take, pigpen.core/sample,
            pigpen.core/distinct, pigpen.core/filter-by</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/filter.clj#L51">Source</a></div></div><div class="public" id="var-filter-by"><h3>filter-by</h3><h4 class="macro">macro</h4><div class="usage"><code>(filter-by key-selector keys relation)</code><code>(filter-by key-selector keys opts relation)</code></div><pre class="doc">Filters a relation by the keys in another relation. The key-selector function
is applied to each element of relation. If the resulting key is present in keys,
the value is kept. Otherwise it is dropped. nils are dropped or preserved based
on whether there is a nil value present in keys. This operation is referred to
as a semi-join in relational databases.

  Example:

    (let [keys (pig/return [1 3 5])
          data (pig/return [{:k 1, :v &quot;a&quot;}
                            {:k 2, :v &quot;b&quot;}
                            {:k 3, :v &quot;c&quot;}
                            {:k 4, :v &quot;d&quot;}
                            {:k 5, :v &quot;e&quot;}])]
      (pig/filter-by :k keys data))

    =&gt; (pig/dump *1)
    [{:k 1, :v &quot;a&quot;}
     {:k 3, :v &quot;c&quot;}
     {:k 5, :v &quot;e&quot;}]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: keys must be distinct before this is used or you will get duplicate values.
  Note: Unlike filter, this joins relation with keys and can be potentially expensive.

  See also: pigpen.core/filter, pigpen.core/remove-by, pigpen.core/intersection</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L403">Source</a></div></div><div class="public" id="var-fold"><h3>fold</h3><h4 class="macro">macro</h4><div class="usage"><code>(fold reducef relation)</code><code>(fold combinef reducef relation)</code></div><pre class="doc">Computes a parallel reduce of the relation. This is done in multiple stages
using reducef and combinef. First, combinef is called with no args to produce a
seed value. Then, reducef reduces portions of the data using that seed value.
Finally, combinef is used to reduce each of the intermediate values. If combinef
is not specified, reducef is used for both. Fold functions defined using
pigpen.fold/fold-fn can also be used.

  Example:

    (pig/fold + foo)
    (pig/fold + (fn [acc _] (inc acc)) foo)
    (pig/fold (fold/fold-fn + (fn [acc _] (inc acc))) foo)

  See pigpen.fold for more info on fold functions.

  Note: Folding an empty sequence will always return an empty sequence:

		=&gt; (-&gt;&gt;
		     (pig/return [])
		     (pig/fold (fold/count))
		     (pig/dump))
		[]</pre><pre class="doc">Added 0.2.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L280">Source</a></div></div><div class="public" id="var-group-by"><h3>group-by</h3><h4 class="macro">macro</h4><div class="usage"><code>(group-by key-selector relation)</code><code>(group-by key-selector opts relation)</code></div><pre class="doc">Groups relation by the result of calling (key-selector item) for each item.
This produces a sequence of map entry values, similar to using seq with a
map. Each value will be a lazy sequence of the values that match key.
Optionally takes a map of options, including :parallel and :fold.

  Example:

    (pig/group-by :a foo)
    (pig/group-by count {:parallel 20} foo)

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/cogroup

  See pigpen.fold for more info on :fold options.</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L195">Source</a></div></div><div class="public" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection opts? relations+)</code></div><pre class="doc">Performs an intersection on all relations provided and returns the distinct
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/intersection
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 3]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/intersection-multiset, pigpen.core/difference</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L199">Source</a></div></div><div class="public" id="var-intersection-multiset"><h3>intersection-multiset</h3><div class="usage"><code>(intersection-multiset opts? relations+)</code></div><pre class="doc">Performs a multiset intersection on all relations provided and returns all
results. Optionally takes a map of options as the first parameter.

  Example:

    (pig/intersection-multiset
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 2 3 3]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  See also: pigpen.core/intersection, pigpen.core/difference</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L223">Source</a></div></div><div class="public" id="var-into"><h3>into</h3><h4 class="macro">macro</h4><div class="usage"><code>(into to relation)</code></div><pre class="doc">Returns a new relation with all values from relation conjoined onto to.

Note: This operation uses a single reducer and won't work for large datasets.

See also: pigpen.core/reduce

Note: Reducing an empty sequence will always return an empty sequence:

=&gt; (-&gt;&gt;
     (pig/return [])
     (pig/into {})
     (pig/dump))
[]</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L225">Source</a></div></div><div class="public" id="var-join"><h3>join</h3><h4 class="macro">macro</h4><div class="usage"><code>(join selects f)</code><code>(join selects f opts)</code></div><pre class="doc">Joins many relations together by a common key. Each relation specifies a
key-selector function on which to join. A function is applied to each join
key and each pair of values from each relation that match that join key.
Optionally takes a map of options.

  Example:

    (pig/join [(foo :on :a)
               (bar :on :b :type :optional)]
              (fn [f b] ...)
              {:parallel 20})

In this example, foo and bar are other pig queries and :a and :b are the
key-selector functions for foo and bar, respectively. These can be any
functions - not just keywords. There can be more than two select clauses.
By default, a matching key value from eatch source relation is required,
meaning that they must exist in all source relations to be part of the output.
To specify a relation as optional, add 'optional' to the select clause. The
third argument is a function used to consolidate matching key values. For each
uniqe key value, this function is called with each set of values from the cross
product of each source relation. By default, this does a standard inner join.
Use 'optional' to do outer joins. The last argument is an optional map of
options.

  Options:

    :parallel - The degree of parallelism to use (pig only)
    :join-nils - Whether nil keys from each relation should be treated as equal

  See also: pigpen.core/cogroup, pigpen.core/union</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L360">Source</a></div></div><div class="public" id="var-keys-fn"><h3>keys-fn</h3><h4 class="macro">macro</h4><div class="usage"><code>(keys-fn &amp; body)</code></div><pre class="doc">Creates a named anonymous function. Useful as a terse substitute for keys
destructuring.

Similar to an anonymous function, which uses positional names for arg:

  #(assoc %1 :foo %2 :bar %3)

`keys-fn` uses named variables that are keys in the input map:

  (keys-fn
    (assoc %
      :foo-copy %foo
      :bar-x-2  (* %bar 2)))

To compare, this is the same function using keys destructuring:

  (fn [{:keys [foo bar], :as value}]
    (assoc value
      :foo-copy foo
      :bar-x-2  (* bar 2)))

When using a large number of destructured variables, this can make a noticeable
difference in code size and readability. This macro simply re-writes the first
form into the second.</pre><pre class="doc">Added 0.3.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/extensions/core.clj#L108">Source</a></div></div><div class="public" id="var-load-clj"><h3>load-clj</h3><div class="usage"><code>(load-clj location)</code></div><pre class="doc">Loads clojure data from a file. Each line should contain one value and will
be parsed using clojure.edn/read-string into a value.

  Example:

    (pig/load-clj &quot;input.clj&quot;)

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-json

  See: https://github.com/edn-format/edn</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L106">Source</a></div></div><div class="public" id="var-load-csv"><h3>load-csv</h3><div class="usage"><code>(load-csv location)</code><code>(load-csv location separator quotor)</code></div><pre class="doc">Loads data from a csv file. Each line is returned as a vector of strings,
split according to RFC4180(*). The default separator is \, and quote is \&quot;.

  Note: Newlines within cells are not supported due to line-based splitting of files.

  Example:

    (pig/load-csv &quot;input.csv&quot;)
    (pig/load-tsv &quot;input.csv&quot; \, \&quot;)

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-clj, pigpen.core/load-json</pre><pre class="doc">Added 0.2.12</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L88">Source</a></div></div><div class="public" id="var-load-json"><h3>load-json</h3><h4 class="macro">macro</h4><div class="usage"><code>(load-json location)</code><code>(load-json location opts)</code></div><pre class="doc">Loads json data from a file. Each line should contain one value and will be
parsed using clojure.data.json/read-str into a value. Options can be passed to
read-str as a map. The default options used are {:key-fn keyword}.

  Example:

    (pig/load-json &quot;input.json&quot;)

  See also: pigpen.core/load-string, pigpen.core/load-tsv, pigpen.core/load-clj</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L122">Source</a></div></div><div class="public" id="var-load-lazy"><h3>load-lazy</h3><div class="usage"><code>(load-lazy location)</code><code>(load-lazy location delimiter)</code></div><pre class="doc">Loads data from a tsv file. Each line is returned as a lazy seq, split by
the specified delimiter. The default delimiter is \t.

  See also: pigpen.core/load-tsv</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L140">Source</a></div></div><div class="public" id="var-load-string"><h3>load-string</h3><div class="usage"><code>(load-string location)</code></div><pre class="doc">Loads data from a file. Each line is returned as a string.

Example:

  (pig/load-string &quot;input.txt&quot;)

See also: pigpen.core/load-tsv, pigpen.core/load-clj, pigpen.core/load-json</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L59">Source</a></div></div><div class="public" id="var-load-tsv"><h3>load-tsv</h3><div class="usage"><code>(load-tsv location)</code><code>(load-tsv location delimiter)</code></div><pre class="doc">Loads data from a tsv file. Each line is returned as a vector of strings,
split by the specified regex delimiter. The default delimiter is #&quot;\t&quot;.

  Example:

    (pig/load-tsv &quot;input.tsv&quot;)
    (pig/load-tsv &quot;input.csv&quot; #&quot;,&quot;)

  See also: pigpen.core/load-string, pigpen.core/load-clj, pigpen.core/load-json</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L72">Source</a></div></div><div class="public" id="var-map"><h3>map</h3><h4 class="macro">macro</h4><div class="usage"><code>(map f relation)</code></div><pre class="doc">Returns a relation of f applied to every item in the source relation.
Function f should be a function of one argument.

  Example:

    (pig/map inc foo)
    (pig/map (fn [x] (* x x)) foo)

  Note: Unlike clojure.core/map, pigpen.core/map takes only one relation. This
is due to the fact that there is no defined order in pigpen. See pig/join,
pig/cogroup, and pig/union for combining sets of data.

  See also: pigpen.core/mapcat, pigpen.core/map-indexed, pigpen.core/join,
            pigpen.core/cogroup, pigpen.core/union</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/map.clj#L59">Source</a></div></div><div class="public" id="var-map-indexed"><h3>map-indexed</h3><h4 class="macro">macro</h4><div class="usage"><code>(map-indexed f relation)</code><code>(map-indexed f opts relation)</code></div><pre class="doc">Returns a relation of applying f to the the index and value of every item in
the source relation. Function f should be a function of two arguments: the index
and the value. If you require sequential ids, use option {:dense true}.

  Example:

    (pig/map-indexed (fn [i x] (* i x)) foo)
    (pig/map-indexed vector {:dense true} foo)

  Options:

    :dense - force sequential ids (pig only)

  Note: If you require sorted data, use sort or sort-by immediately before
        this command.

  Note: Pig will assign the same index to any equal values, regardless of how
        many times they appear.

  Note: The cascading implementation of map-indexed uses a single reducer

  See also: pigpen.core/sort, pigpen.core/sort-by, pigpen.core/map, pigpen.core/mapcat</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/map.clj#L135">Source</a></div></div><div class="public" id="var-mapcat"><h3>mapcat</h3><h4 class="macro">macro</h4><div class="usage"><code>(mapcat f relation)</code></div><pre class="doc">Returns the result of applying concat, or flattening, the result of applying
f to each item in relation. Thus f should return a collection.

  Example:

    (pig/mapcat (fn [x] [(dec x) x (inc x)]) foo)

  See also: pigpen.core/map, pigpen.core/map-indexed</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/map.clj#L99">Source</a></div></div><div class="public" id="var-reduce"><h3>reduce</h3><h4 class="macro">macro</h4><div class="usage"><code>(reduce f relation)</code><code>(reduce f val relation)</code></div><pre class="doc">Reduce all items in relation into a single value. Follows semantics of
clojure.core/reduce. If a sequence is returned, it is kept as a single value
for further processing.

  Example:

    (pig/reduce + foo)
    (pig/reduce conj [] foo)

  Note: This operation uses a single reducer and won't work for large datasets.
        Use pig/fold to do a parallel reduce.

  See also: pigpen.core/fold, pigpen.core/into

  Note: Reducing an empty sequence will always return an empty sequence:

		=&gt; (-&gt;&gt;
		     (pig/return [])
		     (pig/reduce +)
		     (pig/dump))
		[]</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L247">Source</a></div></div><div class="public" id="var-remove"><h3>remove</h3><h4 class="macro">macro</h4><div class="usage"><code>(remove pred relation)</code></div><pre class="doc">Returns a relation without items for which (pred item) returns true.

Example:

  (pig/remove even? foo)
  (pig/remove (fn [x] (even? (* x x))) foo)

See also: pigpen.core/filter, pigpen.core/take, pigpen.core/sample,
          pigpen.core/distinct, pigpen.core/remove-by</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/filter.clj#L67">Source</a></div></div><div class="public" id="var-remove-by"><h3>remove-by</h3><h4 class="macro">macro</h4><div class="usage"><code>(remove-by key-selector keys relation)</code><code>(remove-by key-selector keys opts relation)</code></div><pre class="doc">Filters a relation by the keys in another relation. The key-selector function
is applied to each element of relation. If the resulting key is _not_ present in
keys, the value is kept. Otherwise it is dropped. nils are dropped or preserved
based on whether there is a nil value present in keys. This operation is
referred to as an anti-join in relational databases.

  Example:

    (let [keys (pig/return [1 3 5])
          data (pig/return [{:k 1, :v &quot;a&quot;}
                            {:k 2, :v &quot;b&quot;}
                            {:k 3, :v &quot;c&quot;}
                            {:k 4, :v &quot;d&quot;}
                            {:k 5, :v &quot;e&quot;}])]
      (pig/remove-by :k keys data))

    =&gt; (pig/dump *1)
    [{:k 2, :v &quot;b&quot;}
     {:k 4, :v &quot;d&quot;}]

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: Unlike remove, this joins relation with keys and can be potentially expensive.

  See also: pigpen.core/remove, pigpen.core/filter-by, pigpen.core/difference</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/join.clj#L443">Source</a></div></div><div class="public" id="var-return"><h3>return</h3><div class="usage"><code>(return data)</code></div><pre class="doc">Returns a constant set of data as a pigpen relation. This is useful for
testing, but not supported in generated scripts. The parameter 'data' must be a
sequence. The values of 'data' can be any clojure type.

  Example:

    (pig/constantly [1 2 3])
    (pig/constantly [{:a 123} {:b 456}])

  See also: pigpen.core/constantly</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L265">Source</a></div></div><div class="public" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample p relation)</code></div><pre class="doc">Samples the input records by p percentage. This is non-deterministic;
different values may selected on subsequent runs. p should be a value
between 0.0 and 1.0

  Example:

    (pig/sample 0.01 foo)

  Note: This is potentially an expensive operation when run locally.

  See also: pigpen.core/filter, pigpen.core/take</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/filter.clj#L97">Source</a></div></div><div class="public" id="var-sort"><h3>sort</h3><h4 class="macro">macro</h4><div class="usage"><code>(sort relation)</code><code>(sort comp relation)</code><code>(sort comp opts relation)</code></div><pre class="doc">Sorts the data with an optional comparator. Takes an optional map of options.

Example:

  (pig/sort foo)
  (pig/sort :desc foo)
  (pig/sort :desc {:parallel 20} foo)

Notes:
  The default comparator is :asc (ascending sort order).
  Only :asc and :desc are supported comparators.
  The values must be primitive values (string, int, etc).
  Maps, vectors, etc are not supported.

Options:

  :parallel - The degree of parallelism to use (pig only)

Note: The cascading implementation of sort uses a single reducer

See also: pigpen.core/sort-by</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/map.clj#L190">Source</a></div></div><div class="public" id="var-sort-by"><h3>sort-by</h3><h4 class="macro">macro</h4><div class="usage"><code>(sort-by key-fn relation)</code><code>(sort-by key-fn comp relation)</code><code>(sort-by key-fn comp opts relation)</code></div><pre class="doc">Sorts the data by the specified key-fn with an optional comparator. Takes an
optional map of options.

  Example:

    (pig/sort-by :a foo)
    (pig/sort-by #(count %) :desc foo)
    (pig/sort-by (fn [x] (* x x)) :desc {:parallel 20} foo)

  Notes:
    The default comparator is :asc (ascending sort order).
    Only :asc and :desc are supported comparators.
    The key-fn values must be primitive values (string, int, etc).
    Maps, vectors, etc are not supported.

  Options:

    :parallel - The degree of parallelism to use (pig only)

  Note: The cascading implementation of sort-by uses a single reducer

  See also: pigpen.core/sort</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/map.clj#L219">Source</a></div></div><div class="public" id="var-store-clj"><h3>store-clj</h3><div class="usage"><code>(store-clj location relation)</code></div><pre class="doc">Stores the relation into location using edn (clojure format). Each value is
written as a single line.

  Example:

    (pig/store-clj &quot;output.clj&quot; foo)

  See also: pigpen.core/store-string, pigpen.core/store-tsv, pigpen.core/store-json

  See: https://github.com/edn-format/edn</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L214">Source</a></div></div><div class="public" id="var-store-json"><h3>store-json</h3><h4 class="macro">macro</h4><div class="usage"><code>(store-json location relation)</code><code>(store-json location opts relation)</code></div><pre class="doc">Stores the relation into location using clojure.data.json. Each value is
written as a single line. Options can be passed to write-str as a map.

  Example:

    (pig/store-json &quot;output.json&quot; foo)

  See also: pigpen.core/store-string, pigpen.core/store-tsv, pigpen.core/store-clj</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L230">Source</a></div></div><div class="public" id="var-store-many"><h3>store-many</h3><div class="usage"><code>(store-many outputs+)</code></div><pre class="doc">Combines multiple store commands into a single script. This is not required
if you have a single output.

  Example:

    (pig/store-many
      (pig/store-tsv &quot;foo.tsv&quot; foo)
      (pig/store-clj &quot;bar.clj&quot; bar))

  Note: When run locally, this will merge the results of any source relations.</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L248">Source</a></div></div><div class="public" id="var-store-string"><h3>store-string</h3><div class="usage"><code>(store-string location relation)</code></div><pre class="doc">Stores the relation into location as a string. Each value is written as a
single line.

  Example:

    (pig/store-string &quot;output.txt&quot; foo)

  See also: pigpen.core/store-tsv, pigpen.core/store-clj, pigpen.core/store-json</pre><pre class="doc">Added 0.2.3</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L182">Source</a></div></div><div class="public" id="var-store-tsv"><h3>store-tsv</h3><div class="usage"><code>(store-tsv location relation)</code><code>(store-tsv location delimiter relation)</code></div><pre class="doc">Stores the relation into location as a tab-delimited file. Thus, each input
value must be sequential. Complex values are stored as edn (clojure format).
Single string values are not quoted. You may optionally pass a different delimiter.

  Example:

    (pig/store-tsv &quot;output.tsv&quot; foo)
    (pig/store-tsv &quot;output.csv&quot; &quot;,&quot; foo)

  See also: pigpen.core/store-string, pigpen.core/store-clj, pigpen.core/store-json</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/io.clj#L196">Source</a></div></div><div class="public" id="var-take"><h3>take</h3><div class="usage"><code>(take n relation)</code></div><pre class="doc">Limits the number of records to n items.

Example:

  (pig/take 200 foo)

Note: This is potentially an expensive operation when run on the server.

See also: pigpen.core/filter, pigpen.core/sample</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/filter.clj#L82">Source</a></div></div><div class="public" id="var-union"><h3>union</h3><div class="usage"><code>(union opts? relations+)</code></div><pre class="doc">Performs a union on all relations provided and returns the distinct results.
Optionally takes a map of options as the first parameter.

  Example:

    (pig/union
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 2 3 4 5]

  Options:

    :parallel - the degree of parallelism to use (pig only)

  See also: pigpen.core/union-multiset, pigpen.core/distinct</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L127">Source</a></div></div><div class="public" id="var-union-multiset"><h3>union-multiset</h3><div class="usage"><code>(union-multiset relations+)</code></div><pre class="doc">Performs a union on all relations provided and returns all results.
Identical to pigpen.core/concat.

  Example:

    (pig/union-multiset
      (pig/return [1 2 2 3 3 3 4 5])
      (pig/return [1 2 2 3 3])
      (pig/return [1 1 2 2 3 3]))

    =&gt; [1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 4 5]

  See also: pigpen.core/union, pigpen.core/distinct, pigpen.core/concat</pre><pre class="doc">Added 0.1.0</pre><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/master/pigpen-core/src/main/clojure/pigpen/set.clj#L177">Source</a></div></div></div></body></html>