<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>pigpen.core.fn documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Pigpen</span> <span class="project-version">0.3.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pigpen</span></div></div></li><li class="depth-2 branch"><a href="pigpen.avro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>avro</span></div></a></li><li class="depth-2 branch"><a href="pigpen.cascading.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cascading</span></div></a></li><li class="depth-2"><a href="pigpen.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch current"><a href="pigpen.core.fn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fn</span></div></a></li><li class="depth-3"><a href="pigpen.core.op.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>op</span></div></a></li><li class="depth-2 branch"><a href="pigpen.fold.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>fold</span></div></a></li><li class="depth-2 branch"><a href="pigpen.parquet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parquet</span></div></a></li><li class="depth-2 branch"><a href="pigpen.pig.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pig</span></div></a></li><li class="depth-2 branch"><a href="pigpen.rx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rx</span></div></a></li><li class="depth-2"><a href="pigpen.viz.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>viz</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="pigpen.core.fn.html#var-filter*"><div class="inner"><span>filter*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-fold*"><div class="inner"><span>fold*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-group*"><div class="inner"><span>group*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-join*"><div class="inner"><span>join*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-load-string*"><div class="inner"><span>load-string*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-map*"><div class="inner"><span>map*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-map-indexed*"><div class="inner"><span>map-indexed*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-mapcat*"><div class="inner"><span>mapcat*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-reduce*"><div class="inner"><span>reduce*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-set-op*"><div class="inner"><span>set-op*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-sort*"><div class="inner"><span>sort*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-store-string*"><div class="inner"><span>store-string*</span></div></a></li><li class="depth-1"><a href="pigpen.core.fn.html#var-trap"><div class="inner"><span>trap</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">pigpen.core.fn</h1><div class="doc"><pre class="plaintext">*** ALPHA - Subject to change ***

  Function versions of the core pigpen macros. These are useful if you want to
generate more dynamic scripts, where functions are passed as arguments. This
also means that the functions passed must either be quoted manually or with
pigpen.core.fn/trap. See pigpen.core.fn/map* for example.

  Note: You most likely don't want this namespace. Unless you are doing advanced
things, stick to pigpen.core</pre></div><div class="public anchor" id="var-filter*"><h3>filter*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(filter* pred relation)</code><code>(filter* pred opts relation)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/filter, but is a function and takes a quoted function
as an argument.

  Examples:

    (filter*
      (trap (fn [x] (even? (* x x))))
      data)

  See also: pigpen.core/filter, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/filter.clj#L31">view source</a></div></div><div class="public anchor" id="var-fold*"><h3>fold*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(fold* fold relation)</code><code>(fold* fold opts relation)</code></div><div class="doc"><pre class="plaintext">Applies the fold function `fold` to the data. Similar to pigpen.core/fold,
but is a function and `fold` must be quoted.

  Example:

    (fold* '(fold/count) data)

  See also: pigpen.core/fold, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L140">view source</a></div></div><div class="public anchor" id="var-group*"><h3>group*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(group* selects f)</code><code>(group* selects f opts)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/cogroup, but is a function and takes a quoted function
as an argument. Also takes select clauses as maps.

  Example:

    (group*
      [{:from data1, :by (trap (fn [x] (* x x)))}
       {:from data2, :by 'identity}]
      (trap (fn [k l r] {:key k, :left l, :right r})))

  See also: pigpen.core/group-by, pigpen.core/cogroup, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L82">view source</a></div></div><div class="public anchor" id="var-join*"><h3>join*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(join* selects f)</code><code>(join* selects f opts)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/join, but is a function and takes a quoted function
as an argument. Also takes select clauses as maps.

  Example:

    (join*
      [{:from data1, :by (trap (fn [x] (* x x)))}
       {:from data2, :by 'identity}]
      (trap (fn [l r] {:left l, :right r})))

  See also: pigpen.core/join, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L166">view source</a></div></div><div class="public anchor" id="var-load-string*"><h3>load-string*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(load-string* location f)</code><code>(load-string* location requires f)</code></div><div class="doc"><pre class="plaintext">The base for load-string, load-clj, load-json, etc. The parameters `requires`
and `f` specify a conversion function to apply to each input row. `f` must be
quoted prior to calling load-string*.

  Examples:

    (oad-string*
      "input.txt"
      (trap (fn [x] (subs x 42)))
      data)

  See also: pigpen.core/load-string, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L37">view source</a></div></div><div class="public anchor" id="var-map*"><h3>map*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(map* f relation)</code><code>(map* f opts relation)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/map, but is a function and takes a quoted function as
an argument.

  Examples:

    (defn do-stuff [f data]
      (map* f data))

    (do-stuff 'inc)

    (do-stuff
      (pigpen.core.fn/trap
        (fn [x] (* x x))))

Note that the above example would not work with pigpen.core/map because f would
be compiled before do-stuff is called.

  See also: pigpen.core/map, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L31">view source</a></div></div><div class="public anchor" id="var-map-indexed*"><h3>map-indexed*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(map-indexed* f relation)</code><code>(map-indexed* f opts relation)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/map-indexed, but is a function and takes a quoted
function as an argument.

  Examples:

    (map-indexed*
      (trap (fn [i x] (* i x)))
      data)

  See also: pigpen.core/map-indexed, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L113">view source</a></div></div><div class="public anchor" id="var-mapcat*"><h3>mapcat*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(mapcat* f relation)</code><code>(mapcat* f opts relation)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/mapcat, but is a function and takes a quoted function
as an argument.

  Examples:

    (mapcat*
      (trap (fn [x] [(dec x) x (inc x)]))
      data)

  See also: pigpen.core/mapcat, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L79">view source</a></div></div><div class="public anchor" id="var-reduce*"><h3>reduce*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(reduce* f relation)</code><code>(reduce* f opts relation)</code></div><div class="doc"><pre class="plaintext">Reduces all data into a single collection and applies f to that collection.
The function `f` must be quoted prior to calling reduce*.

  Example:

    (reduce*
      (trap (fn [xs] (count xs)))
      data)

  See also: pigpen.core/into, pigpen.core/reduce, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/join.clj#L119">view source</a></div></div><div class="public anchor" id="var-set-op*"><h3>set-op*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(set-op* f opts? relations+)</code></div><div class="doc"><pre class="plaintext">Common base for most set operations. Takes a quoted function that should take
the same number of args as there are relations passed to set-op*. Each of those
args is a sequence of the same values from that relation, similar to a cogroup
where the key-fn is identity. `f` should return a sequence which is then
flattened.

  Example:

    (set-op*
      (trap
        (fn [&amp; args] (mapv count args)))
      data1
      data2
      ...
      dataN)

  See also: pigpen.core/intersection, pigpen.core/difference, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/set.clj#L51">view source</a></div></div><div class="public anchor" id="var-sort*"><h3>sort*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(sort* comp relation)</code><code>(sort* key-selector comp relation)</code><code>(sort* key-selector comp opts relation)</code></div><div class="doc"><pre class="plaintext">Similar to pigpen.core/sort-by, but is a function and takes a quoted
function as an argument.

  Examples:

    (sort*
      (trap (fn [x] (* x x)))
      :asc
      data)

  See also: pigpen.core/sort, pigpen.core/sort-by, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/map.clj#L164">view source</a></div></div><div class="public anchor" id="var-store-string*"><h3>store-string*</h3><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(store-string* location f relation)</code><code>(store-string* location requires f relation)</code></div><div class="doc"><pre class="plaintext">The base for store-string, store-clj, store-json, etc. The parameters
`requires` and `f` specify a conversion function to apply to each input row.
`f` must be quoted prior to calling store-string*.

  Examples:

    (store-string*
      "input.txt"
      (trap (fn [x] (with-out-str (clojure.pprint/pprint x))))
      data)

  See also: pigpen.core/store-string, pigpen.core.fn/trap</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/io.clj#L159">view source</a></div></div><div class="public anchor" id="var-trap"><h3>trap</h3><h4 class="type">macro</h4><h4 class="added">added in 0.3.0</h4><div class="usage"><code>(trap f)</code><code>(trap ns f)</code></div><div class="doc"><pre class="plaintext">Returns a form that, when evaluated, will reconsitiute f in namespace ns, in
the presence of any local bindings. If `ns` is not specified, the current
namespace, *ns*, is used.

  Examples:

    =&gt; (trap (fn [x] (* x x)))
    (pigpen.runtime/with-ns pigpen-demo.core
      (fn [x] (* x x)))

    =&gt; (let [y (* 21 2)]
         (trap
           (fn [x] (+ x y))))
    (pigpen.runtime/with-ns pigpen-demo.core
      (clojure.core/let [y (quote 42)]
        (fn [x] (+ x y))))

  Note: `ns` must exist as a file that will be in the final deployed uberjar.
        If you are in a temporary namespace in a REPL, it will not be included
        in the rewritten version of the expression.</pre></div><div class="src-link"><a href="https://github.com/Netflix/PigPen/blob/0.3.3/pigpen-core/src/main/clojure/pigpen/code.clj#L132">view source</a></div></div></div></body></html>